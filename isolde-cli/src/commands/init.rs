//! # Isolde init command
//!
//! Initialize a new Isolde project with a configuration file.

use std::fs;
use std::path::{Path, PathBuf};

use colored::Colorize;
use isolde_core::config::{Config, GitConfig, GitGeneratedHandling};
use isolde_core::{Error, Result};

/// Options for the init command
#[derive(Debug, Clone)]
pub struct InitOptions {
    /// Template to use (optional)
    pub template: Option<String>,

    /// Preset to use (optional)
    pub preset: Option<String>,

    /// Skip confirmation prompts
    pub yes: bool,

    /// Current working directory
    pub cwd: PathBuf,

    /// Project name (for non-interactive mode)
    pub name: Option<String>,
}

impl Default for InitOptions {
    fn default() -> Self {
        Self {
            template: None,
            preset: None,
            yes: false,
            cwd: PathBuf::from("."),
            name: None,
        }
    }
}

/// Generate a default isolde.yaml configuration
fn generate_default_config(project_name: &str) -> String {
    format!(
        r#"# Isolde Configuration for {name}
# Generated by isolde init

name: {name}
version: 1.0.0

workspace:
  dir: ./project

docker:
  image: mcr.microsoft.com/devcontainers/base:ubuntu
  build_args: []

claude:
  version: latest
  provider: anthropic
  models:
    haiku: claude-3-5-haiku-20241022
    sonnet: claude-3-5-sonnet-20241022
    opus: claude-3-5-sonnet-20241022

# Runtime configuration (optional)
# runtime:
#   language: python
#   version: "3.12"
#   package_manager: uv
#   tools: []

# Proxy configuration for corporate networks (optional)
# proxy:
#   http: http://proxy.corp.com:8080
#   https: http://proxy.corp.com:8080
#   no_proxy: localhost,127.0.0.1,.local

# Marketplace configurations (optional)
# marketplaces:
#   omc:
#     url: https://github.com/oh-my-claudecode/marketplace

# Plugin configurations (optional)
# plugins:
#   - marketplace: omc
#     name: oh-my-claudecode
#     activate: true

# Git configuration
git:
  generated: ignored
"#,
        name = project_name
    )
}

/// Generate configuration from a preset
fn generate_config_from_preset(project_name: &str, preset_name: &str) -> Result<String> {
    // Try to load presets.yaml from the current directory or template repository
    let preset_yaml = load_presets_yaml()?;

    // Parse the preset configuration
    let preset = find_preset(&preset_yaml, preset_name)?;

    // Generate config based on preset
    let config = format!(
        r#"# Isolde Configuration for {name}
# Generated from preset: {preset}

name: {name}
version: 1.0.0

workspace:
  dir: ./project

docker:
  image: mcr.microsoft.com/devcontainers/base:ubuntu
  build_args: []

claude:
  version: latest
  provider: anthropic
  models:
    haiku: claude-3-5-haiku-20241022
    sonnet: claude-3-5-sonnet-20241022
    opus: claude-3-5-sonnet-20241022

runtime:
  language: {lang}
  version: "{version}"
  package_manager: auto
  tools: {tools}

# Plugin configurations
plugins:
{plugins}

# Git configuration
git:
  generated: ignored
"#,
        name = project_name,
        preset = preset_name,
        lang = preset.template,
        version = preset.lang_version,
        tools = serde_yaml::to_string(&preset.features).unwrap_or_else(|_| "[]".to_string()),
        plugins = preset
            .claude_plugins
            .iter()
            .map(|p| format!("  - marketplace: omc\n    name: {}\n    activate: true", p))
            .collect::<Vec<_>>()
            .join("\n")
    );

    Ok(config)
}

/// Load presets.yaml from the current directory or template repository
fn load_presets_yaml() -> Result<String> {
    // Try current directory first
    let local_path = PathBuf::from("presets.yaml");
    if local_path.exists() {
        return fs::read_to_string(&local_path).map_err(|e| {
            Error::FileError(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!("Failed to read presets.yaml: {}", e),
            ))
        });
    }

    // Try to load from the isolde repository
    // In a real implementation, this would use the repository path
    // For now, return an error if not found locally
    Err(Error::InvalidTemplate(
        "presets.yaml not found. Please run this command from the Isolde repository root.".to_string(),
    ))
}

/// Find and extract a preset from the YAML
fn find_preset(yaml: &str, preset_name: &str) -> Result<PresetData> {
    use isolde_core::config::Preset;

    // Parse the presets YAML
    let value: serde_yaml::Value = serde_yaml::from_str(yaml)
        .map_err(|e| Error::InvalidTemplate(format!("Failed to parse presets.yaml: {}", e)))?;

    let presets = value
        .get("presets")
        .and_then(|v| v.as_mapping())
        .ok_or_else(|| Error::InvalidTemplate("No presets found in presets.yaml".to_string()))?;

    let preset_value = presets
        .get(serde_yaml::Value::String(preset_name.to_string()))
        .ok_or_else(|| Error::PresetNotFound(preset_name.to_string()))?;

    // Try to parse as Preset
    let preset: Preset = serde_yaml::from_value(preset_value.clone())
        .map_err(|e| Error::InvalidTemplate(format!("Failed to parse preset '{}': {}", preset_name, e)))?;

    Ok(PresetData {
        template: preset.template.clone(),
        lang_version: preset.lang_version.clone(),
        features: preset.features.clone(),
        claude_plugins: preset.claude_plugins.clone(),
    })
}

/// Simplified preset data structure
#[derive(Debug, Clone)]
struct PresetData {
    template: String,
    lang_version: String,
    features: Vec<String>,
    claude_plugins: Vec<String>,
}

/// Run the init command
pub fn run(opts: InitOptions) -> Result<()> {
    let config_path = opts.cwd.join("isolde.yaml");

    // Check if isolde.yaml already exists
    if config_path.exists() {
        return Err(Error::Other(format!(
            "isolde.yaml already exists at {}. Use --force to overwrite.",
            config_path.display()
        )));
    }

    // Determine project name
    let project_name = opts.name.unwrap_or_else(|| {
        opts
            .cwd
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("my-project")
            .to_string()
    });

    // Generate configuration
    let config_content = if let Some(preset) = &opts.preset {
        print!(
            "{}",
            format!("Loading preset '{}'...\n", preset.cyan()).dimmed()
        );
        generate_config_from_preset(&project_name, preset)?
    } else {
        generate_default_config(&project_name)
    };

    // Validate the configuration
    let config = Config::from_str(&config_content)?;

    // Show preview
    println!("\n{}", "Configuration preview:".bold());
    println!("{}", "─".repeat(50));
    println!("  Name: {}", config.name.cyan());
    println!("  Version: {}", config.version);
    println!("  Workspace: {}", config.workspace.dir);
    println!("  Docker Image: {}", config.docker.image);
    println!("  Claude Provider: {}", config.claude.provider);
    if let Some(runtime) = &config.runtime {
        println!(
            "  Runtime: {} {}",
            runtime.language,
            runtime.version
        );
    }
    println!("{}", "─".repeat(50));

    // Ask for confirmation
    if !opts.yes {
        print!(
            "\n{}",
            "Create isolde.yaml with this configuration? [Y/n] ".bold()
        );
        use std::io::Write;
        std::io::stdout().flush().unwrap();

        let mut input = String::new();
        std::io::stdin()
            .read_line(&mut input)
            .map_err(|e| Error::Other(format!("Failed to read input: {}", e)))?;

        let input = input.trim().to_lowercase();
        if !input.is_empty() && input != "y" && input != "yes" {
            println!("{}", "Aborted.".yellow());
            return Ok(());
        }
    }

    // Write configuration file
    fs::write(&config_path, config_content)
        .map_err(|e| Error::FileError(std::io::Error::new(std::io::ErrorKind::Other, format!("Failed to write isolde.yaml: {}", e))))?;

    println!(
        "\n{} {}",
        "✔".green(),
        format!("Created isolde.yaml at {}", config_path.display()).green()
    );
    println!(
        "{}",
        "Run 'isolde sync' to generate the devcontainer configuration.".dimmed()
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_default_config() {
        let config = generate_default_config("test-project");
        assert!(config.contains("name: test-project"));
        assert!(config.contains("workspace:"));
        assert!(config.contains("docker:"));
        assert!(config.contains("claude:"));
    }

    #[test]
    fn test_init_options_default() {
        let opts = InitOptions::default();
        assert!(opts.template.is_none());
        assert!(opts.preset.is_none());
        assert!(!opts.yes);
    }
}
